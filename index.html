<!DOCTYPE html>
<html lang="ko" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Vue basic</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  </head>
  <body>
    <div id="app">
      {{otherMethod("안녕하세요")}}<br>
      <!-- data binding : data를 태그에 연결. v-bind: or : -->
      <input v-bind:type="type" v-bind:value="inputData"><br>
      <a :href="link">link_to_youtube</a><br>
      <!-- function 응용 가능 -->
      <a :href="linkAdapter('kossiecoder')">this_is_kossiecoder_ch</a><br>
      <button type="button" onclick="alert('this is just html')">htmlBTN</button>
      <button v-on:click="alert">AboutEvent</button><br>
      <!-- button event 응용 -->
      <p>button event 응용</p>
      {{year}}<br>
      <button type="button" name="button" v-on:click="yearInc()">yearIncrease</button>
      <button type="button" name="button" v-on:click="yearDec()">yearDecrease</button>
      <!-- another event -->
      <!-- form = 기본적으로 submit시, page를 reload함. 그래서 순식간에 log가 사라짐 -->
      <!-- .prevent = preventDefault. js에서 tag의 기본 기능을 막아주는 함수. -->
      <form v-on:submit.prevent="submit()">
        <!-- <input type="text" name="" :value="text" @keyup="changeText"><br> -->
        <!-- 양방향 데이터 바인딩 -->
        <input type="text" v-model="text"><br>
        {{text}}<br>
        <button type="submit" name="button">Submit</button>
      </form> <br>
      <!-- about computed : 다음과 같은 경우, 유지보수가 어려워질 수 있음-->
      <!-- 역순: {{message.split('').reverse().join('')}} -->
      <!-- 따라서 computed를 활용해 계산을 적용시킨 값을 return한다. -->
      <p>원본 : "{{message}}"</p>
      <p>역순 : "{{reversedMessage}}"</p>
      <button type="button" @click="messageChange">ChangeMessage</button>

      <p>{{watchMessage}}</p>
      <button type="button" @click="watchChange">AboutWatch</button><br>
      <p>{{updated}}</p>
    </div>
    <script>
      new Vue({
        el: '#app',
        data: {
          person: {
            name: "name",
            age : 26
          },
          inputData: '23',
          type: 'number',
          link: 'https://www.youtube.com',
          year: 2020,
          text: "text",
          message: "Hello world!",
          changed: true,
          watchMessage: "WhatIsWatch",
          updated: true,
        },
        methods: {
          nextYear: function(){
            return this.person.name + "는 내년에 " + (this.person.age + 1) + "살이 된다.";
          },
          // function을 지우고 줄여서 사용 가능
          otherMethod(greeting){
            return greeting + "! " + this.nextYear();
          },
          linkAdapter(address){
            return this.link+"/"+address;
          },
          alert(){
            alert('hello this is Vue methods');
          },
          yearInc(){
            this.year++;
          },
          yearDec(){
            this.year--;
          },
          submit(){
            alert('submitted');
            console.log('hello');
          },
          // changeText(e){
          //   this.text = e.target.value;
          // },
          messageChange(){
            if(this.changed){
              this.message = "GoodBye, World!!";
            } else{
              this.message = "Hello, World!!"
            }
            this.changed = !this.changed;
          },
          watchChange(){
            this.watchMessage = "WatchIs...";
          }
        },
        computed: {
          // 계산이 적용된 결과를 get!!!
          // computed와 method의 차이?
          // method는 cache를 사용하지 않으므로 해당하는 코드에 도달했을 때, 계산 결과를 반환한다. 하지만 computed는 cache를 사용하여, Vue 객체가 생성될 때 해당 이름을 가진 변수 값을 계산하여 반환해둔다.
          // 3회 호출 시, method = 3회 계산, computed = 1회 계산.
          // message값이 변경되면 실시간으로 반영되어 값이 변경된다.
          reversedMessage(){
            return this.message.split('').reverse().join('');
          },
        },
        // watch=computed와 유사. 대부분 computed로 사용 가능.
        watch: {
          watchMessage(newVal, oldVal){
            console.log(newVal, oldVal);
            this.updated = !this.updated;
          }
        }
      })
    </script>
  </body>
</html>
